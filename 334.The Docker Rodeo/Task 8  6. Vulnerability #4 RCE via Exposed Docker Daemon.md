 6.1. Unix Sockets 101 (no travel adapter required)  

If I were to mention the word "socket" you would most likely think of networking, right? Well, you're not wrong in doing so. With that said, what is often seldom discussed is UNIX sockets...Put simply, a UNIX socket accomplishes the same job as it's networking sibling - moving data, albeit all within the host itself by using the filesystem rather than networking interfaces/adapters; Interprocess Communication (IPC) is an essential part to an operating system. Due to the fact that UNIX sockets use the filesystem directly, you can use filesystem permissions to decide who or what can read/write.

There was an interesting [benchmark test](https://www.percona.com/blog/2020/04/13/need-to-connect-to-a-local-mysql-server-use-unix-domain-socket/) between using both types of sockets for querying a MySQL database. Notice in the screenshot below how there are an incredibly higher amount of queries performed when using UNIX sockets; database systems such as Redis are known for their performance due to this reason.  

![](https://www.percona.com/blog/wp-content/uploads/2020/04/image2-2.png)

[(Percona., 2020)](https://www.percona.com/blog/2020/04/13/need-to-connect-to-a-local-mysql-server-use-unix-domain-socket/)

6.2. How does this pertain to Docker?

Users interact with Docker by using the Docker Engine. For example, commands such as `docker pull` or `docker run` will be executed by the use of a socket - this can either be a UNIX or a TCP socket, but by default, it is a UNIX socket. This is why you must be a part of the "docker" group to use the docker command (remembering that UNIX sockets can use file permissions here!) as illustrated below:

The user "**cmnatic**" is in the "**docker**" group  

![](https://assets.tryhackme.com/additional/docker-rodeo/dockerapi/groups1.png)  

And can therefore run commands like `docker images`  

![](https://assets.tryhackme.com/additional/docker-rodeo/dockerapi/groups2.png)  

Whereas, the user "**notcmnatic**" is not in the "**docker**" group and cannot run Docker commands due to lack of permissions to the Docker socket.  

![](https://assets.tryhackme.com/additional/docker-rodeo/dockerapi/groups4.png)  

![](https://assets.tryhackme.com/additional/docker-rodeo/dockerapi/groups3.png)  

6.3. Automating all the things

Developers love to automate, and this is proven nonetheless with Docker. Whilst Docker uses a UNIX socket, meaning that it can only interact from the host itself. However, someone may wish to remotely execute Docker commands such as in Docker management tools like Portainer or DevOps applications like Jenkins to test their program.

To achieve this, the daemon must use a TCP socket instead, permitting data for the Docker daemon to be communicated using the network interface and ultimately exposing it to the network for us to exploit.  

---

6.4. Practical:

6.4.1. Enumerate, enumerate, enumerate...  
We'll need to enumerate the host to look for this exposed service. By default, the engine will run on port **2375** - let's confirm this by performing another Nmap scan against your Instance (10.10.216.184).

_Please note that you may need to upgrade your version of Nmap (or proceed to "Step 2") if this port does not appear in your Nmap scan._

![](https://assets.tryhackme.com/additional/docker-rodeo/dockerapi/nmap1.png)  

6.4.2. Confirming vulnerability.  
Great! Looks like it's open, we're going to use the `curl` command to start interacting with the exposed Docker daemon.

Confirming that we can access the Docker daemon:

`curl http://10.10.216.184:2375/version`

And note that we receive a response will all sorts of data about the host - lovely!  

![](https://assets.tryhackme.com/additional/docker-rodeo/dockerapi/curl1.png)  

6.4.3. Execute  
We'll perform our first Docker command by using the "**-H**" switch to specify the Instance to list the containers runningÂ `docker -H tcp://10.10.216.184:2375 ps`

![](https://assets.tryhackme.com/additional/docker-rodeo/dockerapi/docker1.png)

6.4.4. Experiment  
Of course, listing the running containers is the least that we can do at this stage. We can start to create our own, extract their filesystems and look for data, or execute commands on the host itself. Here are a few docker commands that I'll leave for you to experiment with:

Command  Description  

network ls  Used to list the networks of containers, we could use this to discover other applications running and pivot to them from our machine!  

images  List images used by containers, data can also be exfiltrated by reverse-engineering the image.  

exec  Execute a command on a container  

run  Run a container  

Experiment with some [Docker commands](https://raw.githubusercontent.com/sangam14/dockercheatsheets/master/dockercheatsheet8.png) to enumerate the machine, try to gain a shell onto some of the containers and take a look at using tools such as [rootplease](https://registry.hub.docker.com/r/chrisfosterelli/rootplease) to use Docker to create a root shell on the device itself.

Answer the questions below

I've executed some Docker commands remotely on the vulnerable Instance